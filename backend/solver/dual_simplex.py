# -*- coding: utf-8 -*-
"""Dual_simplex.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_ml2HUSMkWa_tInw9Fb__ZzZq6Nl874h
"""

import copy


class DualSimplex:

    # --------------------------------------------------
    def __init__(self, problem, show_steps=True):

        self.original_problem = copy.deepcopy(problem)
        self.problem = None

        self.standard_form = None
        self.tableau = None
        self.columns = None

        self.original_type = problem["type"]
        self.show_steps = show_steps
        self.iteration = 0

        self.logs = []


    # --------------------------------------------------
    # TAKE USER INPUT
    # --------------------------------------------------
    

    # --------------------------------------------------
    # Normalize MAX ‚Üí MIN and convert to <=
    # --------------------------------------------------
    def _normalize_problem(self):
        p = copy.deepcopy(self.original_problem)

        if p["type"] == "max":
            p["objective"]["coefficients"] = {
                k: -v for k, v in p["objective"]["coefficients"].items()
            }
            p["type"] = "min"

        for c in p["constraints"]:
            if c["relation"] != "<=":
                c["lhs"] = {k: -v for k, v in c["lhs"].items()}
                c["rhs"] *= -1
                c["relation"] = "<="

        self.problem = p

    # --------------------------------------------------
    # Build Standard Form
    # --------------------------------------------------
    def _build_standard_form(self):

        decision_vars = list(self.problem["objective"]["coefficients"].keys())

        standard = {
            "variables": {"decision": decision_vars[:], "slack": []},
            "equations": [],
            "objective": self.problem["objective"]["coefficients"].copy()
        }

        for i, c in enumerate(self.problem["constraints"], start=1):
            s = f"S{i}"

            eq = {"coefficients": {}, "rhs": c["rhs"]}

            for v in decision_vars:
                eq["coefficients"][v] = c["lhs"].get(v, 0)

            eq["coefficients"][s] = 1

            standard["variables"]["slack"].append(s)
            standard["equations"].append(eq)

        self.standard_form = standard

    # --------------------------------------------------
    # Build Tableau
    # --------------------------------------------------
    def _build_initial_tableau(self):

        self.columns = (
            self.standard_form["variables"]["decision"]
            + self.standard_form["variables"]["slack"]
        )

        table = []

        for eq in self.standard_form["equations"]:
            row = [eq["coefficients"].get(v, 0) for v in self.columns]
            row.append(eq["rhs"])
            table.append(row)

        obj = self.standard_form["objective"]
        f_row = [-obj.get(v, 0) for v in self.columns]
        f_row.append(0)

        table.append(f_row)

        self.tableau = table

    # --------------------------------------------------
    # Print Tableau (Tabular)
    # --------------------------------------------------
    def _log_tableau(self):

        snapshot = {
            "title": f"Iteration {self.iteration}",
            "columns": self.columns + ["RHS"],
            "rows": []
        }

        for row in self.tableau:
            snapshot["rows"].append(row.copy())

        self.logs.append(snapshot)


    # --------------------------------------------------
    # Find Pivot
    # --------------------------------------------------
    def _find_pivot(self, tol=1e-9):

        rhs = [row[-1] for row in self.tableau[:-1]]
        pivot_row = min(range(len(rhs)), key=lambda i: rhs[i])

        if rhs[pivot_row] >= -tol:
            return None

        f_row = self.tableau[-1][:-1]

        ratios = {}
        for j, a in enumerate(self.tableau[pivot_row][:-1]):
            if a < -tol:
                ratio = f_row[j] / a
                if ratio > tol:
                    ratios[j] = ratio

        if not ratios:
            raise Exception("‚ùå Infeasible Problem")

        pivot_col = min(ratios, key=ratios.get)
        return pivot_row, pivot_col

    # --------------------------------------------------
    # Pivot
    # --------------------------------------------------
    def _pivot(self, pr, pc):

        pv = self.tableau[pr][pc]
        self.tableau[pr] = [x / pv for x in self.tableau[pr]]

        for i in range(len(self.tableau)):
            if i == pr:
                continue
            factor = self.tableau[i][pc]
            self.tableau[i] = [
                self.tableau[i][j] - factor * self.tableau[pr][j]
                for j in range(len(self.tableau[0]))
            ]

    # --------------------------------------------------
    # Iteration Loop
    # --------------------------------------------------
    def _iterate(self):

        while True:

            self._log_tableau()

            pivot_pos = self._find_pivot()

            if pivot_pos is None:
                break

            pr, pc = pivot_pos
            self._pivot(pr, pc)
            self.iteration += 1


    # --------------------------------------------------
    # Extract Solution
    # --------------------------------------------------
    def _extract_solution(self):

        decision_vars = self.standard_form["variables"]["decision"]
        solution = {v: 0 for v in decision_vars}

        for j, var in enumerate(self.columns):
            col = [self.tableau[i][j] for i in range(len(self.tableau)-1)]

            if col.count(1) == 1 and col.count(0) == len(col)-1:
                solution[var] = self.tableau[col.index(1)][-1]

        obj = self.tableau[-1][-1]

        if self.original_type == "max":
            obj = -obj

        solution["objective_value"] = obj
        return solution

    # --------------------------------------------------
    def solve(self):

        self._normalize_problem()
        self._build_standard_form()
        self._build_initial_tableau()
        self._iterate()

        final_solution = self._extract_solution()
        print(final_solution)


        return {
            "solution": final_solution,
            "tables": self.logs,
            "columns": self.columns
        }


# solver = DualSimplex()
# result = solver.solve()

# print("\nüéØ FINAL SOLUTION:")